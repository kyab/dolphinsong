<html>
<head>
<style type="text/css">

body{
	background-color:lightgray;
}

#control{
	background-color:lightgreen;
	font-size:20;
	text-align: center;
	height: 50;
}

#editor{
	margin: 10px 20px;
	text-align: center;

	position: relative;
}

#editor canvas {
	position: absolute;
	top: 0;
	left: 0;
}

#player {
	/*text-align: center;*/
	position:relative;
	top:220;
	left:100;
}

#player table{
	text-align:center;
	border-collapse:collapse;
	background-color:lightcyan;
}

#player table th, #player table td{
	padding: 5px;
	border : 1px solid black;
	width:100px;
	cursor: default;
}

#player table td:hover{
	background-color: lightblue;
}


</style>

<script type="text/javascript">
	'use strict';

	var mydata = {};
	mydata.monitor = false;
	mydata.currentFrame = 0;
	mydata.currentFramePlay = 0;

	mydata.recording = false;
	mydata.playing = false;
	mydata.outAudio = null;

	mydata.needsRedrawWave = false;

	mydata.dragging = false;
	mydata.shiftDragging = false;

	mydata.viewStartFrame = 0;
	mydata.viewEndFrame = 0;
	mydata.viewCenterFrame = 0;
	mydata.viewRate = 1.0;
	mydata.selectStartFrame = 0;
	mydata.selectEndFrame = 0 ;
	mydata.selected = false;
	mydata.selectDragStartFrame = 0;
	mydata.shiftDraggingForLeft = false;

	mydata.trackLoaded = new Array(4);

	mydata.trackBufferLeft = new Array(4);
	mydata.trackBufferRight = new Array(4);
	mydata.trackPlaying = new Array(4);
	mydata.trackCurrentFrame = new Array(4);
	mydata.trackLength = new Array(4);
	mydata.trackRatio = new Array(4);
	for (let i=0;i<4;i++){
		mydata.trackLoaded[i] = false;
		mydata.trackPlaying[i] = false;
		mydata.trackRatio[i] = 1;
		mydata.trackCurrentFrame[i] = 0;
		mydata.trackLength[i] = 0;
	}


	mydata.isEditorActive = false;
	mydata.isPlayerActive = false;
	mydata.timer = null;

	mydata.grain_size = 6000;

	var audioContext;
	var audioContext2;

	var audioElem;
	var audioElem2;


	var audioBufferLeft = new Float32Array(44100*60*10);
	var audioBufferRight = new Float32Array(44100*60*10);


	var calcState = {};
	calcState.start = 0;
	calcState.end = 3000;
	calcState.i = 0;
	calcState.currentFrame = 0;
	
	calcState.stretchedLX = new Array(4);
	calcState.stretchedRX = new Array(4);
	calcState.current_grain_start = new Array(4);
	calcState.current_x = new Array(4);
	calcState.current_grain_start2 = new Array(4);
	calcState.current_x2 = new Array(4);
	for (let i = 0; i < 4; i++){
		calcState.stretchedLX[i] = new Float32Array(44100*60);
		calcState.stretchedRX[i] = new Float32Array(44100*60);
		calcState.current_grain_start[i] = 0;
		calcState.current_x[i] = 0;
		calcState.current_grain_start2[i] = mydata.grain_size / 2;
		calcState.current_x2[i] = -1.0 * (mydata.grain_size/2*mydata.trackRatio[i]);
	}


	window.addEventListener("resize", function(e){
		onResize();
	});

	function onResize(){
		let canvas = document.querySelector("#canvas");
		let canvas2 = document.querySelector("#canvas2");
		let w = document.body.clientWidth;
		canvas.width = w - 60;
		canvas2.width = w - 60;

		mydata.needsRedrawWave = true;
		redrawCanvas();
	}

	window.addEventListener("load", function(){
		initMedia();

		let canvas2 = document.querySelector("#canvas2");
		canvas2.addEventListener("mousedown", onCanvasMousedown, false);
		canvas2.addEventListener("mousemove", onCanvasMousemove, false);
		canvas2.addEventListener("mouseup", onCanvasMouseup, false);

		canvas2.addEventListener("wheel", onCanvasScroll, false);

		onResize();

		const loadButtons = document.querySelectorAll(".loadButton");
		loadButtons.forEach(function(b){
			b.addEventListener("click", onLoadButtonClicked, false);
			b.addEventListener("dragover", function(e){
				e.preventDefault();
				e.dataTransfer.dropEffect = "copy";
			});
			b.addEventListener("drop", onTrackDrop,false);
		});

		const playButtons = document.querySelectorAll(".playButton");
		playButtons.forEach(function(b){
			b.addEventListener("click", onPlayButtonClicked, false);
		});

		const speedSliders = document.querySelectorAll(".speedSlider");
		speedSliders.forEach(function(s){
			s.addEventListener("input", onSpeedSliderChanged, false);
		});
		canvas2.addEventListener("dragover", function(e){
			e.preventDefault();
			e.dataTransfer.dropEffect = "copy";
		});
		canvas2.addEventListener("drop", onEditorDrop, false);

	});

	function onSpeedSliderChanged(e){
		const slider = e.currentTarget;

		let index = 0;
		const speedSliders = document.querySelectorAll(".speedSlider");
		for (let i = 0; i < speedSliders.length; i++){
			if (slider == speedSliders[i]){
				index = i;
				break;
			}
		}
		onSpeedChanged(index);
	}

	function onLoadButtonClicked(e){
		const btn = e.currentTarget;

		let index = 0;
		const loadButtons = document.querySelectorAll(".loadButton");
		for(let i = 0; i < loadButtons.length;i++){
			if (btn == loadButtons[i]){
				index = i;
				break;
			}
		}
		onLoadSample(index);
	}

	function onPlayButtonClicked(e){
		const btn = e.currentTarget;

		let index = 0;
		const playButtons = document.querySelectorAll(".playButton");
		for(let i = 0; i < playButtons.length;i++){
			if (btn == playButtons[i]){
				index = i;
				break;
			}
		}
		onPlayStopTrack(index);
	}

	function onTrackDrop(e){
		const btn = e.currentTarget;
		e.preventDefault();

		let index = 0;
		const loadButtons = document.querySelectorAll(".loadButton");
		for(let i = 0; i < loadButtons.length;i++){
			if (btn == loadButtons[i]){
				index = i;
				break;
			}
		}
		const file = e.dataTransfer.files[0];
		onLoadSampleFromFile(index, file);
	}

	function onEditorDrop(e){
		e.preventDefault();

		const file = e.dataTransfer.files[0];
		onEditorLoadSampleFromFile(file);
	}

	function onLoadSample(index){
		console.log("loading sample for track:" + (index+1));

		mydata.trackLength[index] = mydata.selectEndFrame - mydata.selectStartFrame;
		
		mydata.trackBufferLeft[index] = new Float32Array(mydata.trackLength[index]);
		mydata.trackBufferRight[index] = new Float32Array(mydata.trackLength[index]);
		for (let i = 0; i < mydata.trackLength[index]; i++){
			mydata.trackBufferLeft[index][i] = 
						audioBufferLeft[mydata.selectStartFrame + i];
			mydata.trackBufferRight[index][i] = 
						audioBufferRight[mydata.selectStartFrame + i];					
		}
		mydata.trackCurrentFrame[index] = 0;
		mydata.trackPlaying[index] = false;
		mydata.trackLoaded[index] = true;
	}

	function onLoadSampleFromFile(index, file){
		console.log("dropped file : " + file.name + " for track:" +(index+1));
		const fileReader = new FileReader();
		fileReader.onload = function(e){
			const fileContents = e.target.result;
			const audioContextForDecode = new AudioContext();
			audioContextForDecode.decodeAudioData(fileContents)
			.then(function(buf){
				console.log("decode ok " + buf.length + " frames");
				mydata.trackLength[index]  = buf.length;
				mydata.trackBufferLeft[index] = buf.getChannelData(0);
				if (buf.numberOfChannels == 1){
					mydata.trackBufferRight[index] = buf.getChannelData(0);
				}else{
					mydata.trackBufferRight[index] = buf.getChannelData(1);
				}
				mydata.trackCurrentFrame[index] = 0;
				mydata.trackPlaying[index] = 0;
				mydata.trackLoaded[index] = true;
				audioContextForDecode.close();
				// stretch2(index);
				console.log("decode done.");
			}, function(e){
				console.log("decode error :");
				console.log(e);

			});

		};
		fileReader.readAsArrayBuffer(file);

	}

	function onSpeedChanged(index){
		const speedSlider = document.querySelectorAll(".speedSlider")[index];
		const speedLabel = document.querySelectorAll(".speedLabel")[index];

		const val = speedSlider.value;
		mydata.trackRatio[index] = val / 100.0;

		// calcState.current_grain_start[index] = 0;
		// calcState.current_x[index] = 0;
		// calcState.current_grain_start2[index] = mydata.grain_size / 2;
		// calcState.current_x2[index] = -1.0 * (mydata.grain_size/2*mydata.trackRatio[index]);

		speedLabel.innerHTML = val.toString() + "%";
	}

	function sinFadeWindow(fadeStartRate, x, val){
		let y = 0;

		if (x < 0 || x > 1) {return 0;}
		if (x < fadeStartRate){
			y = 1.0/2.0 * Math.sin(Math.PI/fadeStartRate*x + 3.0/2*Math.PI) + 1/2;
		}else if (x < 1.0 - fadeStartRate){
			y = 1.0;
		}else{
			y = 1.0/2.0 * Math.sin(Math.PI/fadeStartRate*x + 3.0/2.0 * Math.PI 
			- 1.0/fadeStartRate*Math.PI ) + 1.0/2.0;
		}
		return val * y;
	}

	function crossfadeWindow(fadeStartRate, x, val){
		
		if (x < 0 || x > 1) {return 0;}

		if (x < fadeStartRate){
			return val * (1.0/fadeStartRate  * x); 
		}else if (x < 1.0 - fadeStartRate){
			return val * 1.0;
		}else{
			return val * ( (-1.0/fadeStartRate*x + 1/fadeStartRate));
		}
	}


	function stretch2(index){

		let grain_size = 4000;
		let ratio = 1.5;

		let start = 0;
		let end = grain_size;

		let stretchedL = new Float32Array(44100*60*10);
		let stretchedR = new Float32Array(44100*60*10);
		while(true){
			for (let i = start; i < end; i++){

				let valL = mydata.trackBufferLeft[index][i];
				let valR = mydata.trackBufferRight[index][i];

				let fadeStartRate = -1/2*ratio + 1;
				valL = sinFadeWindow(fadeStartRate, (i-start)/grain_size, valL);
				valR = sinFadeWindow(fadeStartRate, (i-start)/grain_size, valR);

				let iX = Math.round(start * ratio) + (i-start);
				stretchedL[iX] += valL;
				stretchedR[iX] += valR;
			}
			start = start + grain_size/2;
			end = end + grain_size/2;
			if (start > mydata.trackLength[index]){
				break;
			}
		}

		mydata.trackBufferLeft[index] = stretchedL;
		mydata.trackBufferRight[index] = stretchedR;
		mydata.trackLength[index] = Math.round(mydata.trackLength[index] * ratio);
	}

	function stretch_continue3(index, inBufL, inBufR, len){

		let grain_size = mydata.grain_size;
		let ratio = mydata.trackRatio[index];

		for (let iX = 0; iX < len; iX++){

			if (calcState.current_x[index] > grain_size * (1+ (ratio-1)/2)){
				calcState.current_grain_start[index] += grain_size;
				calcState.current_x[index] = (grain_size *  (1+(ratio-1)/2) - grain_size)*(-1)
			}
			if (calcState.current_x2[index] > grain_size * (1+(ratio-1)/2)){
				calcState.current_grain_start2[index] += grain_size;
				calcState.current_x2[index] = (grain_size * (1+(ratio-1)/2) - grain_size)*(-1);
			}

			const fadeStartRate = -1/2*ratio + 1;
			{
				let x = calcState.current_grain_start[index] + calcState.current_x[index];

				let valL = mydata.trackBufferLeft[index][x];
				let valR = mydata.trackBufferRight[index][x];

				valL = sinFadeWindow(fadeStartRate, calcState.current_x[index]/grain_size, valL);
				valR = sinFadeWindow(fadeStartRate, calcState.current_x[index]/grain_size, valR);
				calcState.stretchedLX[index][mydata.trackCurrentFrame[index]] = valL;
				calcState.stretchedRX[index][mydata.trackCurrentFrame[index]] = valR;
			}

			{
				let x2 = calcState.current_grain_start2[index] + calcState.current_x2[index];
				let valL2 = mydata.trackBufferLeft[index][x2];
				let valR2 = mydata.trackBufferRight[index][x2];

				valL2 = sinFadeWindow(fadeStartRate, calcState.current_x2[index]/grain_size, valL2);
				valR2 = sinFadeWindow(fadeStartRate, calcState.current_x2[index]/grain_size, valR2);
				calcState.stretchedLX[index][mydata.trackCurrentFrame[index]] += valL2;
				calcState.stretchedRX[index][mydata.trackCurrentFrame[index]] += valR2;				
			}
			calcState.current_x[index]++;
			calcState.current_x2[index]++;

		
			inBufL[iX] += calcState.stretchedLX[index][mydata.trackCurrentFrame[index]];
			inBufR[iX] += calcState.stretchedRX[index][mydata.trackCurrentFrame[index]];
			
			mydata.trackCurrentFrame[index]++;
			if (calcState.current_grain_start[index] + calcState.current_x[index] > mydata.trackLength[index]){
				mydata.trackCurrentFrame[index] = 0;
				calcState.current_grain_start[index] = 0;
				calcState.current_x[index] = 0;
				calcState.current_grain_start2[index] = mydata.grain_size / 2;
				calcState.current_x2[index] = -1.0 * (mydata.grain_size/2*mydata.trackRatio[index]);
			}
	
		}
	}

	function onEditorLoadSampleFromFile(file){
		const fileReader = new FileReader();
		fileReader.onload = function(e){
			const fileContents = e.target.result;
			let audioContextForDecode = new AudioContext();
			audioContextForDecode.decodeAudioData(fileContents)
			.then(function(buf){
				console.log("decode ok " + buf.length + " frames");
				mydata.currentFrame = buf.length;
				for (let i = 0; i < buf.length; i++){
					audioBufferLeft[i] = buf.getChannelData(0)[i];
					if (buf.numberOfChannels == 1){
						audioBufferRight[i] = buf.getChannelData(0)[i];
					}else{
						audioBufferRight[i] = buf.getChannelData(1)[i];
					}
				}
				mydata.viewStartFrame = 0;
				mydata.viewEndFrame = buf.length;
				mydata.viewRate = 1.0;
				mydata.recording = false;
				mydata.playing = false

				mydata.selectStartFrame = 0;
				mydata.selectEndFrame = buf.length;
				mydata.selected = true;
				mydata.playStartFrame = 0;
				mydata.needsRedrawWave = true;
				audioContextForDecode.close();
				redrawCanvas();

			}, function(e){
				console.log("decode error :");
				console.log(e);

			});
			
		}
		fileReader.readAsArrayBuffer(file);
	}


	function onPlayStopTrack(index){
		if(mydata.trackLoaded[index]){
			if (!mydata.trackPlaying[index]){
				mydata.trackCurrentFrame[index] = 0;
				calcState.current_grain_start[index] = 0;
				calcState.current_x[index] = 0;
				calcState.current_grain_start2[index] = mydata.grain_size / 2;
				calcState.current_x2[index] = -1.0 * (mydata.grain_size/2*mydata.trackRatio[index]);

				mydata.trackPlaying[index] = true;


			}else{
				mydata.trackPlaying[index] = false;
			}
		}

		playStateChanged();
	}

	function playStateChanged(){

		startStopTimer();

		let shouldStop = true;
		if (mydata.playing){
			shouldStop = false
		}
		for (let i=0; i < 4; i++){
			if (mydata.trackLoaded[i] && mydata.trackPlaying[i]){
				shouldStop = false;
			}
		}

		if (shouldStop && audioContext2){
			audioContext2.suspend();
			audioContext2.close();
			audioContext2 = null;
			audioElem2.pause();
			audioElem2 = null;
			mydata.isPlayerActive = false;
			console.log("audioEngine stopped");
			return;
		}

		if (!shouldStop && (audioContext2==null)) {
			console.log("now start engine");
			startOutEngine();
		}

	}

	function editorStateChanged(){
		startStopTimer();

		let shouldStop = true;
		if (mydata.monitor){
			shouldStop = false;
		}
		if (mydata.recording){
			shouldStop = false;
		}

		if(shouldStop && mydata.isEditorActive){
			audioContext.close();
			audioContext = null;
			audioElem.pause();
			audioElem = null;
			mydata.isEditorActive = false;
			return;
		}

		if(!shouldStop && !mydata.isEditorActive){
			streamObtained(mydata.stream);
		}

	}

	function startStopTimer(){
		let shouldStop = true;
		if (mydata.recording){
			shouldStop = false;
		}
		if (mydata.playing){
			shouldStop = false;
		}

		if (shouldStop && (mydata.timer != null)){
			clearInterval(mydata.timer);
			mydata.timer = null;
			return;
		}

		if (!shouldStop && (mydata.timer==null)){
			mydata.timer = setInterval(function(){
				redrawCanvas();
			},50);
		}


	}


	function initMedia(){
		navigator.mediaDevices.getUserMedia(
						{audio:true, video:false})
		.then( function(stream){
			console.log("calling getOutputBuiltIn()");
			return getOutputBuiltIn();

		}).then(function(){
			console.log("calling readyInput()");
			return readyInput();
		
		}).then(function(){
			// console.log("calling startOutEngine()");
			// return startOutEngine();
		});

	}

	function getOutputBuiltIn(){

		return new Promise(function(resolve, reject) {
			navigator.mediaDevices.enumerateDevices()
			.then(function(devices){
				var devId = "";
				
				devices.forEach(function(device){
					if (device.kind == "audiooutput"){
						// console.log(device.label + " id = " + device.deviceId);
						if (device.label.startsWith("内蔵スピーカー") || 
							device.label.startsWith("ヘッドフォン")){
							console.log("found!!!(内蔵スピーカー/ヘッドフォン)");
							devId = device.deviceId;
							mydata.outDevId = devId;
						}
					}
				});
				if (devId == ""){
					console.log("built-in output not found!");
				}
				resolve();
			});
		});
	}


	function readyInput(){
		return new Promise(function(resolve,reject){
			navigator.mediaDevices.enumerateDevices()
			.then(function(devices){
				var devId = "";
				
				devices.forEach(function(device){
					if (device.kind == "audioinput"){
						// console.log(device.label + " id = " + device.deviceId);
						if (device.label.startsWith("Background Music")){
							console.log("Background Music device found!!!");
							if (devId == ""){
								devId = device.deviceId;
								mydata.inDevId = devId;
							}
						}
					}
				});

				if (devId == ""){
					console.log("Background Music device not found");
					return;
				}

				var constrains = {
					audio:{
						deviceId : devId,
						sampleSize : 16,
						sampleRate : 44100,
						channelCount : 2,
						echoCancellation: false, /*this is the point*/
	      				autoGainControl: false,/*this is the point*/
	      				noiseSuppression: false/*this is the point*/
					},
					video:false
				};
				var p = navigator.mediaDevices.getUserMedia(constrains)
				p.then(function(stream){
					mydata.stream = stream;
					// streamObtained(stream);
					resolve();
				});
			});
		});
	}


	function streamObtained(stream) {
        
		audioContext = new AudioContext();		

		var mediastreamsource = audioContext.createMediaStreamSource(stream);
		
		var scriptProcessor = audioContext.createScriptProcessor(0, 2, 2);
  	    scriptProcessor.onaudioprocess = onAudioProcess;

  	    var dest = audioContext.createMediaStreamDestination();

        mediastreamsource.connect(scriptProcessor);
        scriptProcessor.connect(dest);

		audioElem = new Audio();
		audioElem.srcObject = dest.stream;
		audioElem.setSinkId(mydata.outDevId);
		audioElem.play();
		mydata.isEditorActive = true;

   	}

   	function startOutEngine(){
   		audioContext2 = new AudioContext();
   		var scriptSource = audioContext2.createScriptProcessor(256/*latency*/,2,2);
   		scriptSource.onaudioprocess = onAudioProcessOut;
   		var dest = audioContext2.createMediaStreamDestination();
   		scriptSource.connect(dest);

   		audioElem2 = new Audio();
   		audioElem2.srcObject = dest.stream;
   		audioElem2.setSinkId(mydata.outDevId);
   		audioElem2.play();
   		mydata.isPlayerActive = true;

   		console.log("startOutEngine() completed.")
   	}

	function onAudioProcess(e) {
		console.log("onAudioProcess");

		let inbuf = e.inputBuffer;
		let outbuf = e.outputBuffer;

		if (mydata.monitor){
	    	for (let i=0; i < inbuf.getChannelData(0).length; i++){
	    		outbuf.getChannelData(0)[i] = inbuf.getChannelData(0)[i];
	    		outbuf.getChannelData(1)[i] = inbuf.getChannelData(1)[i];
	    	}
	    } else {
	    	const len = inbuf.getChannelData(0).length;
	    	const outLeft = outbuf.getChannelData(0);
	    	const outRight = outbuf.getChannelData(1);
	    	for (let i=0; i < len; i++){
	    		outLeft[i] = 0;
	    		outRight[i] = 0;
	    	}
	    }

	    if (mydata.recording){
	    	for (let i=0; i < inbuf.getChannelData(0).length; i++){
		    	audioBufferLeft[mydata.currentFrame] = inbuf.getChannelData(0)[i];
    			audioBufferRight[mydata.currentFrame] = inbuf.getChannelData(1)[i];
    			mydata.currentFrame++;
    			mydata.viewEndFrame++;
    			mydata.viewRate = 1.0;
    			mydata.needsRedrawWave = true;

    		}
	    }
	};

	function onAudioProcessOut(e){
		// console.log("onAudioProcessOut");
		let outLeft = e.outputBuffer.getChannelData(0);
		let outRight = e.outputBuffer.getChannelData(1);
		
		if (mydata.playing){
			for (let i = 0 ; i < outLeft.length; i++){
				outLeft[i] = audioBufferLeft[mydata.currentFramePlay];
				outRight[i] = audioBufferRight[mydata.currentFramePlay];
				mydata.currentFramePlay++;

				if (mydata.selected){
					if (mydata.currentFramePlay > mydata.selectEndFrame){
						mydata.currentFramePlay = mydata.selectStartFrame;
					}					
				}else{
					if (mydata.currentFramePlay > mydata.currentFrame){
						mydata.playing = false;
						redrawCanvas();
						playStateChanged();

						break;
					}
				}

			}
		}else{
			for (let i = 0 ; i < outLeft.length; i++){
				outLeft[i] = 0;
				outRight[i] = 0;
			}
		}

		//mix track data
		for (let i = 0; i < 4; i++){
			if (mydata.trackPlaying[i]){
				// for(let j = 0; j < outLeft.length;j++){
				// 	outLeft[j] += mydata.trackBufferLeft[i][mydata.trackCurrentFrame[i]];
				// 	outRight[j] += mydata.trackBufferRight[i][mydata.trackCurrentFrame[i]];
				// 	mydata.trackCurrentFrame[i]++;
				// 	if (mydata.trackCurrentFrame[i] > mydata.trackLength[i]){
				// 		mydata.trackCurrentFrame[i] = 0;
					
				// 	}
				// }
				stretch_continue3(i, outLeft, outRight, outLeft.length);
			}
		}

	}

	function startRecord(){
		mydata.currentFrame = 0;
		mydata.viewStartFrame = 0;
		mydata.viewEndFrame = 0;
		mydata.playStartFrame = 0;
		mydata.viewRate = 1.0;
		mydata.recording = true;

		mydata.selectStartFrame = 0;
		mydata.selectEndFrame = 0;
		mydata.playStartFrame = 0;

		mydata.needsRedrawWave = true;
		redrawCanvas();

		editorStateChanged();
	}

	function stopRecord(){
		mydata.recording = false;
		mydata.needsRedrawWave = true;
		redrawCanvas();
		editorStateChanged();

	}

	function startPlay(){
		if(mydata.selected){
			mydata.currentFramePlay = mydata.selectStartFrame;
		}else{

			mydata.currentFramePlay = mydata.playStartFrame;
		}
		//playStateChanged();
		mydata.playing = true;	
		playStateChanged();
	}

	function stopPlay(){

		mydata.playing = false;
		playStateChanged();
	}

	function redrawCanvas(){
		// console.log("redrawCanvas");

		const canvas = document.querySelector("#canvas");

		const w = canvas.width;
		const h = canvas.height;

		let c = canvas.getContext('2d');
		
		if (mydata.needsRedrawWave){

			c.clearRect(0,0,w,h);

			c.beginPath();
			c.fillStyle = "black";
			c.rect(0,0,w,h);
			c.fill();

			//optimization 2

			const framePerPixel = (mydata.viewEndFrame - mydata.viewStartFrame) / w ;
			
			for (let i = 0; i < w; i++){
				let from = Math.floor(i * framePerPixel);
				let to = Math.floor(from + framePerPixel);
				if (to > mydata.viewEndFrame) to = mydata.viewEndFrame;
				let max = 0;

				for(let j = from; j < to; j += Math.ceil((framePerPixel)/100)){
					const s = Math.abs(audioBufferLeft[j + mydata.viewStartFrame]);
					if (s > max) max = s;
				}

				if (max == 0) { //no sound
					max = 0.002;
				}

				c.beginPath();
				c.strokeStyle = "lightgreen";
				c.moveTo(i, h/2 - max*h/2);
				c.lineTo(i, h/2 + max*h/2);
				c.stroke();
			}	
		}
		mydata.needsRedrawWave = false;


		c = document.querySelector("#canvas2").getContext('2d');
		c.clearRect(0,0,w,h);
		const framePerPixel = mydata.currentFrame / w/mydata.viewRate;

		//selection
		if (mydata.selected){
			c.beginPath();
			c.fillStyle ="rgb(123,123,123,0.6)";

			
			let from = (mydata.selectStartFrame - mydata.viewStartFrame) / framePerPixel;
			let to = (mydata.selectEndFrame - mydata.viewStartFrame) / framePerPixel;
			c.rect(from, 0, to - from, h);
			c.fill();
		}


		//start cursor
		c.beginPath();
		c.strokeStype = "blue";
		c.setLineDash([2, 1]);
		let x = (mydata.playStartFrame - mydata.viewStartFrame) / framePerPixel;
		c.moveTo(x,0);
		c.lineTo(x, h);
		c.stroke();

		//play cursor
		c.beginPath();
		c.strokeStyle = "white";
		c.setLineDash([]);
		x = (mydata.currentFramePlay - mydata.viewStartFrame) / framePerPixel;
		c.moveTo(x ,0);
		c.lineTo(x, h);
		c.stroke();
	}

	function onMonitorChanged(){
		const checkBox = document.querySelector("#chkMonitor");
		mydata.monitor = checkBox.checked;
		editorStateChanged();
	}

	document.onkeydown = function (e){
		switch(e.keyCode){
		case 77 /*m*/:
			{
				const checkBox = document.querySelector("#chkMonitor");	
				if (checkBox.checked){
					checkBox.checked = false;
				}else{
					checkBox.checked = true;
				}
				onMonitorChanged();				
			}
			break;

		case 32 /*space*/:
			{
				e.stopPropagation();
				e.preventDefault();
				if (mydata.playing){
					stopPlay();
				}else{
					startPlay();
				}
			}
			break;
		case 39 /*right */:
			if(!e.shiftKey){
				onRight();
			}else{
				onRightWithShift();
			}
			e.stopPropagation();
			e.preventDefault();
			break;
		case 37 /*left */:
			if(!e.shiftKey){
				onLeft();
			}else{
				onLeftWithShift();
			}
			e.stopPropagation();
			e.preventDefault();
			break;
		case 90 /*z*/:
			if (!e.repeat){
				e.stopPropagation();
				e.preventDefault();
				onPlayStopTrack(0);
			}
			break;
		case 88: /*x*/
			if (!e.repeat){
				e.stopPropagation();
				e.preventDefault();
				onPlayStopTrack(1);
			}
			break;
		case 67: /*c*/
			if (!e.repeat){
				e.stopPropagation();
				e.preventDefault();
				onPlayStopTrack(2);
			}
			break;

		case 86: /*v*/
			if (!e.repeat){
				e.stopPropagation();
				e.preventDefault();
				onPlayStopTrack(3);
			}
			break;

		}
	}

	document.onkeyup = function (e){
		switch(e.keyCode){
		case 90 /*z*/:
			e.stopPropagation();
			e.preventDefault();
			onPlayStopTrack(0);
			break;
		case 88: /*x*/
			e.stopPropagation();
			e.preventDefault();
			onPlayStopTrack(1);
			break;
		case 67: /*c*/
			e.stopPropagation();
			e.preventDefault();
			onPlayStopTrack(2);
			break;
		case 86: /*v*/
			e.stopPropagation();
			e.preventDefault();
			onPlayStopTrack(3);
			break;
		}
	}
	function onRight(){
		const w = document.querySelector("#canvas2").width;
		const framePerPixel = mydata.currentFrame/w/mydata.viewRate;

		if(mydata.selected){
			//move start to right
			mydata.selectStartFrame += Math.round(framePerPixel*2);
			mydata.playStartFrame = mydata.selectStartFrame;
		}else{
			//move playStart to right
			mydata.playStartFrame += Math.round(framePerPixel*2);
		}
		redrawCanvas();
	}
	function onLeft(){
		const w = document.querySelector("#canvas2").width;
		const framePerPixel = mydata.currentFrame/w/mydata.viewRate;	

		if(mydata.selected){
			//move start to left
			mydata.selectStartFrame -= Math.round(framePerPixel*2);
			mydata.playStartFrame = mydata.selectStartFrame;
		}else{
			mydata.playStartFrame -= Math.round(framePerPixel*2);
		}
		redrawCanvas();

	}
	function onRightWithShift(){
		const w = document.querySelector("#canvas2").width;
		const framePerPixel = mydata.currentFrame/w/mydata.viewRate;	

		if (mydata.selected){
			//move end to right
			mydata.selectEndFrame += Math.round(framePerPixel*2);
		}else{
			//starting select to right
			mydata.selected = true;
			mydata.selectStartFrame = mydata.playStartFrame;
			mydata.selectEndFrame = mydata.selectStartFrame + Math.round(framePerPixel*2);
		}	
		redrawCanvas();
	}

	function onLeftWithShift(){
		const w = document.querySelector("#canvas2").width;
		const framePerPixel = mydata.currentFrame/w/mydata.viewRate;	

		if (mydata.selected){
			//move end to left
			mydata.selectEndFrame -= Math.round(framePerPixel*2);
		}else{
			//starting select to left
			mydata.selected = true;
			mydata.selectEndFrame = mydata.playStartFrame;
			mydata.selectStartFrame = mydata.selectEndFrame - Math.round(framePerPixel*2);
		}	
		redrawCanvas();


	}


	function onCanvasMousedown(e){

	    const rect = e.target.getBoundingClientRect();
	    const x = e.clientX - rect.left;
	    const canvas = document.querySelector("#canvas2");
	    const w = canvas.width;
		const framePerPixel = (mydata.currentFrame)/w/mydata.viewRate;

		if (!e.shiftKey){
	    	mydata.selectStartFrame = Math.round(mydata.viewStartFrame + framePerPixel*x);
	    	mydata.selectEndFrame = mydata.selectStartFrame;
	    	mydata.selectDragStartFrame = mydata.selectStartFrame;
	    	mydata.selected = false;
	    	mydata.playStartFrame = mydata.selectDragStartFrame;

			mydata.dragging = true;		
			redrawCanvas();
		}else{
			const pointedFrame = Math.round(mydata.viewStartFrame + framePerPixel*x);
			if(mydata.selected){
				if (pointedFrame < mydata.selectStartFrame){
					mydata.shiftDraggingForLeft = true;
					mydata.selectStartFrame = pointedFrame;
					mydata.playStartFrame = pointedFrame;
				}else if (mydata.selectEndFrame < pointedFrame){
					mydata.shiftDraggingForLeft = false;
					mydata.selectEndFrame = pointedFrame;
				}else{
					//between start and end. move nearest
					if((pointedFrame - mydata.selectStartFrame) < (mydata.selectEndFrame - pointedFrame)){
						mydata.shiftDraggingForLeft = true;
						mydata.selectStartFrame = pointedFrame;
						mydata.playStartFrame = pointedFrame;
						
					}else{
						mydata.shiftDraggingForLeft = false;
						mydata.selectEndFrame = pointedFrame;
						mydata.shiftDragStartFromLeft = false;
					}
				}
			}else{
				if (mydata.playStartFrame < pointedFrame){
					mydata.selectStartFrame = mydata.playStartFrame;
					mydata.selectEndFrame = pointedFrame;
					mydata.shiftDraggingForLeft = false;
				}else{
					mydata.selectStartFrame = pointedFrame;
					mydata.selectEndFrame = mydata.playStartFrame;
					mydata.playStartFrame = mydata.selectStartFrame;
					mydata.shiftDraggingForLeft = true;
				}
				mydata.selected = true;
			}
			mydata.shiftDragging = true;
			redrawCanvas();
		}
	}

	function onCanvasMousemove(e){

    	const rect = e.target.getBoundingClientRect();
    	const x = e.clientX - rect.left;
    	const canvas = document.querySelector("#canvas2");
    	const w = canvas.width;
		const framePerPixel = (mydata.currentFrame)/w/mydata.viewRate;
		const pointedFrame = Math.round(mydata.viewStartFrame + framePerPixel*x);

		if (!e.shiftKey){
			if (!mydata.dragging) return;
			if (pointedFrame < mydata.selectDragStartFrame){
				mydata.selectStartFrame = pointedFrame;
				mydata.selectEndFrame = mydata.selectDragStartFrame;
				mydata.playStartFrame = pointedFrame;
			}else{
				mydata.selectStartFrame = mydata.selectDragStartFrame;
				mydata.selectEndFrame = pointedFrame;
				mydata.playStartFrame = mydata.selectStartFrame;
			}

			if (mydata.selectEndFrame - mydata.selectStartFrame > 1){
				mydata.selected = true;
			}else{
				mydata.selected = false;
				mydata.playStartFrame = mydata.selectStartFrame;
			}
			redrawCanvas();
		}else{
			if (!mydata.shiftDragging) return;
			if(mydata.selected){
				if(mydata.shiftDraggingForLeft){
					mydata.selectStartFrame = pointedFrame;
					mydata.playStartFrame = pointedFrame;
				}else{
					mydata.selectEndFrame = pointedFrame;
				}
				
			}else{
				//not come here
				console.log("something wrong");
			}
			redrawCanvas();
		}

		
	}


	function onCanvasMouseup(e){

    	const rect = e.target.getBoundingClientRect();
    	const x = e.clientX - rect.left;
    	const canvas = document.querySelector("#canvas2");
    	const w = canvas.width;
		const framePerPixel = (mydata.currentFrame)/w/mydata.viewRate;
		const pointedFrame = Math.round(mydata.viewStartFrame + framePerPixel*x);

		if(!e.shiftKey){
			if (pointedFrame < mydata.selectDragStartFrame){
				mydata.selectStartFrame = pointedFrame;
				mydata.selectEndFrame = mydata.selectDragStartFrame;
				mydata.playStartFrame = pointedFrame;
			}else{
				mydata.selectStartFrame = mydata.selectDragStartFrame;
				mydata.selectEndFrame = pointedFrame;
				mydata.playStartFrame = mydata.selectStartFrame;
			}

			if (mydata.selectEndFrame - mydata.selectStartFrame > 1){
				mydata.selected = true;
			}else{
				mydata.selected = false;
				mydata.playStartFrame = mydata.selectStartFrame;
			}

			mydata.dragging = false;
			redrawCanvas();
		}else{
			if(mydata.selected){
				if(mydata.shiftDraggingForLeft){
					mydata.selectStartFrame = pointedFrame;
					mydata.playStartFrame = pointedFrame;
				}else{
					mydata.selectEndFrame = pointedFrame;
				}
				
			}else{
				//not come here
				console.log("something wrong");
			}
			mydata.shiftDragging = false;
			redrawCanvas();
		}
		
	}

	function onCanvasScroll(e){
		e.preventDefault();
		// console.log(e);

		if (Math.abs(e.wheelDeltaY) > Math.abs(e.wheelDeltaX)){

			const deltaY = e.wheelDeltaY;
	    	const canvas = document.querySelector("#canvas2");
	      	const w = canvas.width
			const viewGravcenterRatio = /*e.offsetX*/(e.clientX-e.currentTarget.getBoundingClientRect().left) / w;
			let viewGravcenterFrame = Math.round(mydata.viewStartFrame
										+ viewGravcenterRatio * (mydata.viewEndFrame - mydata.viewStartFrame));

			mydata.viewRate += 0.005 * deltaY;
			if (mydata.viewRate < 1.0) mydata.viewRate = 1.0;

			if (mydata.viewRate == 1.0){
				mydata.viewStartFrame = 0;
				mydata.viewEndFrame = mydata.currentFrame;
			}else{
				const framePerPixel = (mydata.currentFrame)/w/mydata.viewRate;
				mydata.viewStartFrame = Math.round(viewGravcenterFrame - framePerPixel * viewGravcenterRatio * w);
				mydata.viewEndFrame = Math.round(viewGravcenterFrame + framePerPixel * (1 - viewGravcenterRatio) * w);
			}

			mydata.needsRedrawWave = true;
			redrawCanvas();
		}else{
			const deltaX = -e.wheelDeltaX;
			const prevStart = mydata.viewStartFrame;
			const prevEnd = mydata.viewEndFrame;
			mydata.viewStartFrame += Math.round(deltaX/mydata.viewRate*120);
			mydata.viewEndFrame += Math.round(deltaX/mydata.viewRate*120);

			if(mydata.viewStartFrame < 0){
				mydata.viewStartFrame = 0;
				mydata.viewEndFrame = mydata.viewStartFrame + (prevEnd - prevStart);
			}
			if(mydata.viewEndFrame > mydata.currentFrame){
				mydata.viewEndFrame = mydata.currentFrame;
				mydata.viewStartFrame = mydata.viewEndFrame - (prevEnd - prevStart);
			}
			mydata.needsRedrawWave = true;
			redrawCanvas();
		}

	}

	//https://qiita.com/HirokiTanaka/items/56f80844f9a32020ee3b
	//https://github.com/mattdiamond/Recorderjs/blob/master/lib/recorder.js
	function exportWAV(){

		let sampleNum = mydata.selectEndFrame - mydata.selectStartFrame;

		function encodeWAV(){
			var buffer = new ArrayBuffer(44 + sampleNum*4 );
			var view = new DataView(buffer);

			function writeString(view, offset, string){
				for (var i = 0; i < string.length; i++){
					view.setUint8(offset+i,string.charCodeAt(i));
				}
			}

			function floatTo16BitPCM(output, offset){
				for (var i = 0; i < sampleNum ;i++,offset+=4){
					var sL = Math.max(-1, Math.min(1, audioBufferLeft[mydata.selectStartFrame+i]));
					output.setInt16(offset, sL < 0 ? sL*0x8000: sL*0x7FFF, true);
				
					var sR = Math.max(-1, Math.min(1, audioBufferRight[mydata.selectStartFrame+i]));
					output.setInt16(offset+2, sR < 0 ? sR*0x8000: sR*0x7FFF, true);
				}
			}

            writeString(view, 0, 'RIFF');  // RIFFヘッダ
            view.setUint32(4, 36 + sampleNum*4, true); // これ以降のファイルサイズ
            writeString(view, 8, 'WAVE'); // WAVEヘッダ
            writeString(view, 12, 'fmt '); // fmtチャンク
            view.setUint32(16, 16, true); // fmtチャンクのバイト数
            view.setUint16(20, 1, true); // フォーマットID
            view.setUint16(22, 2, true); // チャンネル数
            view.setUint32(24, 44100, true); // サンプリングレート
            view.setUint32(28, 44100*4, true); // データ速度
            view.setUint16(32, 4, true); // ブロックサイズ
            view.setUint16(34, 16, true); // サンプルあたりのビット数
            writeString(view, 36, 'data'); // dataチャンク
            view.setUint32(40, sampleNum * 4, true); // 波形データのバイト数
            floatTo16BitPCM(view, 44); // 波形データ

			return view;
		}

		var dataview = encodeWAV();

		var audioBlob = new Blob([dataview], {type:"audio\/wav"});
		var a = document.createElement("a");
		a.download = "sample.wav";
		a.href = window.URL.createObjectURL(audioBlob);
		a.click();

	}


</script>

<title>Dolphin Song</title>
</head>
<body>
<div id="control">
	<input id="chkMonitor" type="checkbox" value="true" onclick="onMonitorChanged();">monitor[m]</input>
	<input type="button" value="startRecord" onclick="startRecord();"/>
	<input type="button" value="stopRecord" onclick="stopRecord();"/>
	<input type="button" value="startPlay" onclick="startPlay();"/>
	<input type="button" value="stopPlay" onclick="stopPlay();"/>
	<input type="button" value="download" onclick="exportWAV();"/>
</div>
<div id="editor">
	<canvas id="canvas" width="500" height="200"></canvas>
	<canvas id="canvas2" dropzone="copy" width="500" height="200"></canvas>
</div>
<div id="player">
	<table>
		<tr>
			<th>track1</th>
			<th>track2</th>
			<th>track3</th>
			<th>track4</th>
		</tr>
		<tr>
			<td class="loadButton" dropzone="copy">load</td>
			<td class="loadButton" dropzone="copy">load</td>
			<td class="loadButton" dropzone="copy">load</td>
			<td class="loadButton" dropzone="copy">load</td>
		</tr>	
		<tr>
			<td class="playButton">play</td>
			<td class="playButton">play</td>
			<td class="playButton">play</td>
			<td class="playButton">play</td>
		</tr>	
		<tr>
			<td>
				<input type="range" class="speedSlider" min="50" max="200" value="100" step="1"/>
				<output class="speedLabel">100%</output>
			</td>
			<td>
				<input type="range" class="speedSlider" min="50" max="200" value="100" step="1"/>
				<output class="speedLabel">100%</output>
			</td>
			<td>
				<input type="range" class="speedSlider" min="50" max="200" value="100" step="1"/>
				<output class="speedLabel">100</output>
			</td>
			<td>
				<input type="range" class="speedSlider" min="50" max="200" value="100" step="1"/>
				<output class="speedLabel">100</output>
			</td>
		</tr>	
	</table>

</body>
</html>
