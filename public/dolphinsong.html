<html>
<head>
<style type="text/css">

body{
	background-color:lightgray;
}

#control{
	background-color:lightgreen;
	font-size:20;
	text-align: center;
	height: 50;
}

#editor{
	margin: 10px 20px;
	text-align: center;

	position: relative;
}

#editor canvas {
	position: absolute;
	top: 0;
	left: 0;
}

#player {
	/*text-align: center;*/
	position:relative;
	top:220;
	left:100;
}

#player table{
	text-align:center;
	border-collapse:collapse;
	background-color:lightcyan;
}

#player table th, #player table td{
	padding: 5px;
	border : 1px solid black;
	width:100px;
	cursor: default;
}

#player table td:hover{
	background-color: lightblue;
}


</style>

<script type="text/javascript">
	'use strict';

	var mydata = {};
	mydata.monitor = false;
	mydata.currentFrame = 0;
	mydata.currentFramePlay = 0;

	mydata.recording = false;
	mydata.playing = false;
	mydata.outAudio = null;

	mydata.needsRedrawWave = false;

	mydata.dragging = false;
	mydata.shiftDragging = false;

	mydata.viewStartFrame = 0;
	mydata.viewEndFrame = 0;
	mydata.viewCenterFrame = 0;
	mydata.viewRate = 1.0;
	mydata.selectStartFrame = 0;
	mydata.selectEndFrame = 0 ;
	mydata.selected = false;
	mydata.selectDragStartFrame = 0;
	mydata.shiftDraggingForLeft = false;

	mydata.trackLoaded = new Array(4);

	mydata.trackBufferLeft = new Array(4);
	mydata.trackBufferRight = new Array(4);
	mydata.trackPlaying = new Array(4);
	mydata.trackCurrentFrame = new Array(4);
	mydata.trackLength = new Array(4);
	for (let i=0;i<4;i++){
		mydata.trackLoaded[i] = false;
		mydata.trackPlaying[i] = false;
	}



	var audioContext;
	var audioContext2;

	var audioElem;

	var audioBufferLeft = new Float32Array(44100*60*10);
	var audioBufferRight = new Float32Array(44100*60*10);

	window.addEventListener("resize", function(e){
		onResize();
	});

	function onResize(){
		let canvas = document.querySelector("#canvas");
		let canvas2 = document.querySelector("#canvas2");
		let w = document.body.clientWidth;
		canvas.width = w - 60;
		canvas2.width = w - 60;

		mydata.needsRedrawWave = true;
		redrawCanvas();
	}

	window.addEventListener("load", function(){
		initMedia();

		let canvas2 = document.querySelector("#canvas2");
		canvas2.addEventListener("mousedown", onCanvasMousedown, false);
		canvas2.addEventListener("mousemove", onCanvasMousemove, false);
		canvas2.addEventListener("mouseup", onCanvasMouseup, false);

		canvas2.addEventListener("wheel", onCanvasScroll, false);

		onResize();

		setInterval(function(){
			redrawCanvas();
		},50);

		const loadButtons = document.querySelectorAll(".loadButton");
		loadButtons.forEach(function(b){
			b.addEventListener("click", onLoadButtonClicked, false);
			b.addEventListener("dragover", function(e){
				e.preventDefault();
				e.dataTransfer.dropEffect = "copy";
			});
			b.addEventListener("drop", onTrackDrop,false);
		});

		const playButtons = document.querySelectorAll(".playButton");
		playButtons.forEach(function(b){
			b.addEventListener("click", onPlayButtonClicked, false);
		});

	});

	function onLoadButtonClicked(e){
		const btn = e.currentTarget;

		let index = 0;
		const loadButtons = document.querySelectorAll(".loadButton");
		for(let i = 0; i < loadButtons.length;i++){
			if (btn == loadButtons[i]){
				index = i;
				break;
			}
		}
		onLoadSample(index);
	}

	function onPlayButtonClicked(e){
		const btn = e.currentTarget;

		let index = 0;
		const playButtons = document.querySelectorAll(".playButton");
		for(let i = 0; i < playButtons.length;i++){
			if (btn == playButtons[i]){
				index = i;
				break;
			}
		}
		onPlayStopTrack(index);
	}

	function onTrackDrop(e){
		const btn = e.currentTarget;
		e.preventDefault();

		let index = 0;
		const loadButtons = document.querySelectorAll(".loadButton");
		for(let i = 0; i < loadButtons.length;i++){
			if (btn == loadButtons[i]){
				index = i;
				break;
			}
		}
		const file = e.dataTransfer.files[0];
		onLoadSampleFromFile(index, file);
	}

	function onLoadSample(index){
		console.log("loading sample for track:" + (index+1));

		mydata.trackLength[index] = mydata.selectEndFrame - mydata.selectStartFrame;
		
		mydata.trackBufferLeft[index] = new Float32Array(mydata.trackLength[index]);
		mydata.trackBufferRight[index] = new Float32Array(mydata.trackLength[index]);
		for (let i = 0; i < mydata.trackLength[index]; i++){
			mydata.trackBufferLeft[index][i] = 
						audioBufferLeft[mydata.selectStartFrame + i];
			mydata.trackBufferRight[index][i] = 
						audioBufferRight[mydata.selectStartFrame + i];					
		}
		mydata.trackCurrentFrame[index] = 0;
		mydata.trackPlaying[index] = false;
		mydata.trackLoaded[index] = true;
	}

	function onLoadSampleFromFile(index, file){
		console.log("dropped file : " + file.name + " for track:" +(index+1));
		const fileReader = new FileReader();
		fileReader.onload = function(e){
			const fileContents = e.target.result;
			audioContext2.decodeAudioData(fileContents)
			.then(function(buf){
				console.log("decode ok " + buf.length + " frames");
				mydata.trackLength[index]  = buf.length;
				mydata.trackBufferLeft[index] = buf.getChannelData(0);
				mydata.trackBufferRight[index] = buf.getChannelData(1);
				mydata.trackCurrentFrame[index] = 0;
				mydata.trackPlaying[index] = 0;
				mydata.trackLoaded[index] = true;
			}, function(e){
				console.log("decode error :");
				console.log(e);

			});

		};
		fileReader.readAsArrayBuffer(file);

	}


	function onPlayStopTrack(index){
		if(mydata.trackLoaded[index]){
			if (!mydata.trackPlaying[index]){
				mydata.trackCurrentFrame[index] = 0;
				mydata.trackPlaying[index] = true;
				console.log("play track " + (index+1));
			}else{
				mydata.trackPlaying[index] = false;
				console.log("stop track " + (index+1));
			}
		}
	}


	function initMedia(){
		navigator.mediaDevices.getUserMedia(
						{audio:true, video:false})
		.then( function(stream){
			console.log("calling getOutputBuiltIn()");
			return getOutputBuiltIn();

		}).then(function(){
			console.log("calling readyInput()");
			return readyInput();
		
		}).then(function(){
			console.log("calling startOutEngine()");
			return startOutEngine();
		});

	}

	function getOutputBuiltIn(){

		return new Promise(function(resolve, reject) {
			navigator.mediaDevices.enumerateDevices()
			.then(function(devices){
				var devId = "";
				
				devices.forEach(function(device){
					if (device.kind == "audiooutput"){
						// console.log(device.label + " id = " + device.deviceId);
						if (device.label.startsWith("内蔵スピーカー") || 
							device.label.startsWith("ヘッドフォン")){
							console.log("found!!!(内蔵スピーカー/ヘッドフォン)");
							devId = device.deviceId;
							mydata.outDevId = devId;
						}
					}
				});
				if (devId == ""){
					console.log("built-in output not found!");
				}
				resolve();
			});
		});
	}


	function readyInput(){
		return new Promise(function(resolve,reject){
			navigator.mediaDevices.enumerateDevices()
			.then(function(devices){
				var devId = "";
				
				devices.forEach(function(device){
					if (device.kind == "audioinput"){
						// console.log(device.label + " id = " + device.deviceId);
						if (device.label.startsWith("Background Music")){
							console.log("Background Music device found!!!");
							if (devId == ""){
								devId = device.deviceId;
								mydata.inDevId = devId;
							}
						}
					}
				});

				if (devId == ""){
					console.log("Background Music device not found");
					return;
				}

				var constrains = {
					audio:{
						deviceId : devId,
						sampleSize : 16,
						sampleRate : 44100,
						channelCount : 2,
						echoCancellation: false, /*this is the point*/
	      				autoGainControl: false,/*this is the point*/
	      				noiseSuppression: false/*this is the point*/
					},
					video:false
				};
				var p = navigator.mediaDevices.getUserMedia(constrains)
				p.then(function(stream){
					streamObtained(stream);
					resolve();
				});
			});
		});
	}


	function streamObtained(stream) {
        
		audioContext = new AudioContext();		

		var mediastreamsource = audioContext.createMediaStreamSource(stream);
		
		var scriptProcessor = audioContext.createScriptProcessor(0, 2, 2);
  	    scriptProcessor.onaudioprocess = onAudioProcess;

  	    var dest = audioContext.createMediaStreamDestination();

        mediastreamsource.connect(scriptProcessor);
        scriptProcessor.connect(dest);

		audioElem = new Audio();
		audioElem.srcObject = dest.stream;
		audioElem.setSinkId(mydata.outDevId);
		audioElem.play();

   	}

   	function startOutEngine(){
   		audioContext2 = new AudioContext();
   		var scriptSource = audioContext2.createScriptProcessor(0,2,2);
   		scriptSource.onaudioprocess = onAudioProcessOut;
   		var dest = audioContext2.createMediaStreamDestination();
   		scriptSource.connect(dest);

   		var audio = new Audio();
   		audio.srcObject = dest.stream;
   		audio.setSinkId(mydata.outDevId);
   		audio.play();

   		console.log("startOutEngine() completed.")
   	}

	function onAudioProcess(e) {

		let inbuf = e.inputBuffer;
		let outbuf = e.outputBuffer;

		if (mydata.monitor){
	    	for (let i=0; i < inbuf.getChannelData(0).length; i++){
	    		outbuf.getChannelData(0)[i] = inbuf.getChannelData(0)[i];
	    		outbuf.getChannelData(1)[i] = inbuf.getChannelData(1)[i];
	    	}
	    } else {
	    	for (let i=0; i < inbuf.getChannelData(0).length; i++){
	    		outbuf.getChannelData(0)[i] = 0;
	    		outbuf.getChannelData(1)[i] = 0;
	    	}
	    }

	    if (mydata.recording){
	    	for (let i=0; i < inbuf.getChannelData(0).length; i++){
		    	audioBufferLeft[mydata.currentFrame] = inbuf.getChannelData(0)[i];
    			audioBufferRight[mydata.currentFrame] = inbuf.getChannelData(1)[i];
    			mydata.currentFrame++;
    			mydata.viewEndFrame++;
    			mydata.viewRate = 1.0;
    			mydata.needsRedrawWave = true;

    		}
	    }
	};

	function onAudioProcessOut(e){
		let outLeft = e.outputBuffer.getChannelData(0);
		let outRight = e.outputBuffer.getChannelData(1);
		
		if (mydata.playing){
			for (let i = 0 ; i < outLeft.length; i++){
				outLeft[i] = audioBufferLeft[mydata.currentFramePlay];
				outRight[i] = audioBufferRight[mydata.currentFramePlay];
				mydata.currentFramePlay++;

				if (mydata.selected){
					if (mydata.currentFramePlay > mydata.selectEndFrame){
						mydata.currentFramePlay = mydata.selectStartFrame;
					}					
				}else{
					if (mydata.currentFramePlay > mydata.currentFame){
						mydata.currentFramePlay = mydata.playStartFrame;
					}
				}

			}
		}else{
			for (let i = 0 ; i < outLeft.length; i++){
				outLeft[i] = 0;
				outRight[i] = 0;
			}
		}

		//mix track data
		for (let i = 0; i < 4; i++){
			if (mydata.trackPlaying[i]){
				for(let j = 0; j < outLeft.length;j++){
					outLeft[j] += mydata.trackBufferLeft[i][mydata.trackCurrentFrame[i]];
					outRight[j] += mydata.trackBufferRight[i][mydata.trackCurrentFrame[i]];
					mydata.trackCurrentFrame[i]++;
					if (mydata.trackCurrentFrame[i] > mydata.trackLength[i]){
						mydata.trackCurrentFrame[i] = 0;
					
					}
				}
			}
		}

	}

	function startRecord(){
		mydata.currentFrame = 0;
		mydata.viewStartFrame = 0;
		mydata.viewEndFrame = 0;
		mydata.playStartFrame = 0;
		mydata.viewRate = 1.0;
		mydata.recording = true;

		mydata.selectStartFrame = 0;
		mydata.selectEndFrame = 0;
		mydata.playStartFrame = 0;

		mydata.needsRedrawWave = true;
		redrawCanvas();
	}

	function stopRecord(){
		mydata.recording = false;
		mydata.needsRedrawWave = true;
		redrawCanvas();

	}

	function startPlay(){
		if(mydata.selected){
			mydata.currentFramePlay = mydata.selectStartFrame;
		}else{

			mydata.currentFramePlay = mydata.playStartFrame;
		}
		mydata.playing = true;	
	}

	function stopPlay(){
		mydata.playing = false;
	}

	function redrawCanvas(){

		const canvas = document.querySelector("#canvas");

		const w = canvas.width;
		const h = canvas.height;

		let c = canvas.getContext('2d');
		
		if (mydata.needsRedrawWave){

			c.clearRect(0,0,w,h);

			c.beginPath();
			c.fillStyle = "black";
			c.rect(0,0,w,h);
			c.fill();

			//optimization 2

			const framePerPixel = (mydata.viewEndFrame - mydata.viewStartFrame) / w ;
			
			for (let i = 0; i < w; i++){
				let from = Math.floor(i * framePerPixel);
				let to = Math.floor(from + framePerPixel);
				if (to > mydata.viewEndFrame) to = mydata.viewEndFrame;
				let max = 0;

				for(let j = from; j < to; j += Math.ceil((framePerPixel)/100)){
					const s = Math.abs(audioBufferLeft[j + mydata.viewStartFrame]);
					if (s > max) max = s;
				}

				if (max == 0) { //no sound
					max = 0.002;
				}

				c.beginPath();
				c.strokeStyle = "lightgreen";
				c.moveTo(i, h/2 - max*h/2);
				c.lineTo(i, h/2 + max*h/2);
				c.stroke();
			}	
		}
		mydata.needsRedrawWave = false;


		c = document.querySelector("#canvas2").getContext('2d');
		c.clearRect(0,0,w,h);
		const framePerPixel = mydata.currentFrame / w/mydata.viewRate;

		//selection
		if (mydata.selected){
			c.beginPath();
			c.fillStyle ="rgb(123,123,123,0.6)";

			
			let from = (mydata.selectStartFrame - mydata.viewStartFrame) / framePerPixel;
			let to = (mydata.selectEndFrame - mydata.viewStartFrame) / framePerPixel;
			c.rect(from, 0, to - from, h);
			c.fill();
		}


		//start cursor
		c.beginPath();
		c.strokeStype = "blue";
		c.setLineDash([2, 1]);
		let x = (mydata.playStartFrame - mydata.viewStartFrame) / framePerPixel;
		c.moveTo(x,0);
		c.lineTo(x, h);
		c.stroke();

		//play cursor
		c.beginPath();
		c.strokeStyle = "white";
		c.setLineDash([]);
		x = (mydata.currentFramePlay - mydata.viewStartFrame) / framePerPixel;
		c.moveTo(x ,0);
		c.lineTo(x, h);
		c.stroke();
	}

	function onMonitorChanged(){
		const checkBox = document.querySelector("#chkMonitor");
		mydata.monitor = checkBox.checked;
	}

	document.onkeydown = function (e){
		switch(e.keyCode){
		case 77 /*m*/:
			{
				const checkBox = document.querySelector("#chkMonitor");	
				if (checkBox.checked){
					checkBox.checked = false;
				}else{
					checkBox.checked = true;
				}
				onMonitorChanged();				
			}
			break;

		case 32 /*space*/:
			{
				console.log("space");
				if (mydata.playing){
					stopPlay();
				}else{
					startPlay();
				}
			}
			break;
		case 39 /*right */:
			if(!e.shiftKey){
				onRight();
			}else{
				onRightWithShift();
			}
			e.stopPropagation();
			e.preventDefault();
			break;
		case 37 /*left */:
			if(!e.shiftKey){
				onLeft();
			}else{
				onLeftWithShift();
			}
			e.stopPropagation();
			e.preventDefault();
			break;

		}
	}

	function onRight(){
		const w = document.querySelector("#canvas2").width;
		const framePerPixel = mydata.currentFrame/w/mydata.viewRate;

		if(mydata.selected){
			//move start to right
			mydata.selectStartFrame += Math.round(framePerPixel*2);
			mydata.playStartFrame = mydata.selectStartFrame;
		}else{
			//move playStart to right
			mydata.playStartFrame += Math.round(framePerPixel*2);
		}
		redrawCanvas();
	}
	function onLeft(){
		const w = document.querySelector("#canvas2").width;
		const framePerPixel = mydata.currentFrame/w/mydata.viewRate;	

		if(mydata.selected){
			//move start to left
			mydata.selectStartFrame -= Math.round(framePerPixel*2);
			mydata.playStartFrame = mydata.selectStartFrame;
		}else{
			mydata.playStartFrame -= Math.round(framePerPixel*2);
		}
		redrawCanvas();

	}
	function onRightWithShift(){
		const w = document.querySelector("#canvas2").width;
		const framePerPixel = mydata.currentFrame/w/mydata.viewRate;	

		if (mydata.selected){
			//move end to right
			mydata.selectEndFrame += Math.round(framePerPixel*2);
		}else{
			//starting select to right
			mydata.selected = true;
			mydata.selectStartFrame = mydata.playStartFrame;
			mydata.selectEndFrame = mydata.selectStartFrame + Math.round(framePerPixel*2);
		}	
		redrawCanvas();
	}

	function onLeftWithShift(){
		const w = document.querySelector("#canvas2").width;
		const framePerPixel = mydata.currentFrame/w/mydata.viewRate;	

		if (mydata.selected){
			//move end to left
			mydata.selectEndFrame -= Math.round(framePerPixel*2);
		}else{
			//starting select to left
			mydata.selected = true;
			mydata.selectEndFrame = mydata.playStartFrame;
			mydata.selectStartFrame = mydata.selectEndFrame - Math.round(framePerPixel*2);
		}	
		redrawCanvas();


	}


	function onCanvasMousedown(e){

	    const rect = e.target.getBoundingClientRect();
	    const x = e.clientX - rect.left;
	    const canvas = document.querySelector("#canvas2");
	    const w = canvas.width;
		const framePerPixel = (mydata.currentFrame)/w/mydata.viewRate;

		if (!e.shiftKey){
	    	mydata.selectStartFrame = Math.round(mydata.viewStartFrame + framePerPixel*x);
	    	mydata.selectEndFrame = mydata.selectStartFrame;
	    	mydata.selectDragStartFrame = mydata.selectStartFrame;
	    	mydata.selected = false;
	    	mydata.playStartFrame = mydata.selectDragStartFrame;

			mydata.dragging = true;		
			redrawCanvas();
		}else{
			const pointedFrame = Math.round(mydata.viewStartFrame + framePerPixel*x);
			if(mydata.selected){
				if (pointedFrame < mydata.selectStartFrame){
					mydata.shiftDraggingForLeft = true;
					mydata.selectStartFrame = pointedFrame;
					mydata.playStartFrame = pointedFrame;
				}else if (mydata.selectEndFrame < pointedFrame){
					mydata.shiftDraggingForLeft = false;
					mydata.selectEndFrame = pointedFrame;
				}else{
					//between start and end. move nearest
					if((pointedFrame - mydata.selectStartFrame) < (mydata.selectEndFrame - pointedFrame)){
						mydata.shiftDraggingForLeft = true;
						mydata.selectStartFrame = pointedFrame;
						mydata.playStartFrame = pointedFrame;
						
					}else{
						mydata.shiftDraggingForLeft = false;
						mydata.selectEndFrame = pointedFrame;
						mydata.shiftDragStartFromLeft = false;
					}
				}
			}else{
				if (mydata.playStartFrame < pointedFrame){
					mydata.selectStartFrame = mydata.playStartFrame;
					mydata.selectEndFrame = pointedFrame;
					mydata.shiftDraggingForLeft = false;
				}else{
					mydata.selectStartFrame = pointedFrame;
					mydata.selectEndFrame = mydata.playStartFrame;
					mydata.playStartFrame = mydata.selectStartFrame;
					mydata.shiftDraggingForLeft = true;
				}
				mydata.selected = true;
			}
			mydata.shiftDragging = true;
			redrawCanvas();
		}
	}

	function onCanvasMousemove(e){

    	const rect = e.target.getBoundingClientRect();
    	const x = e.clientX - rect.left;
    	const canvas = document.querySelector("#canvas2");
    	const w = canvas.width;
		const framePerPixel = (mydata.currentFrame)/w/mydata.viewRate;
		const pointedFrame = Math.round(mydata.viewStartFrame + framePerPixel*x);

		if (!e.shiftKey){
			if (!mydata.dragging) return;
			if (pointedFrame < mydata.selectDragStartFrame){
				mydata.selectStartFrame = pointedFrame;
				mydata.selectEndFrame = mydata.selectDragStartFrame;
				mydata.playStartFrame = pointedFrame;
			}else{
				mydata.selectStartFrame = mydata.selectDragStartFrame;
				mydata.selectEndFrame = pointedFrame;
				mydata.playStartFrame = mydata.selectStartFrame;
			}

			if (mydata.selectEndFrame - mydata.selectStartFrame > 1){
				mydata.selected = true;
			}else{
				mydata.selected = false;
				mydata.playStartFrame = mydata.selectStartFrame;
			}
			redrawCanvas();
		}else{
			if (!mydata.shiftDragging) return;
			if(mydata.selected){
				if(mydata.shiftDraggingForLeft){
					mydata.selectStartFrame = pointedFrame;
					mydata.playStartFrame = pointedFrame;
				}else{
					mydata.selectEndFrame = pointedFrame;
				}
				
			}else{
				//not come here
				console.log("something wrong");
			}
			redrawCanvas();
		}

		
	}


	function onCanvasMouseup(e){

    	const rect = e.target.getBoundingClientRect();
    	const x = e.clientX - rect.left;
    	const canvas = document.querySelector("#canvas2");
    	const w = canvas.width;
		const framePerPixel = (mydata.currentFrame)/w/mydata.viewRate;
		const pointedFrame = Math.round(mydata.viewStartFrame + framePerPixel*x);

		if(!e.shiftKey){
			if (pointedFrame < mydata.selectDragStartFrame){
				mydata.selectStartFrame = pointedFrame;
				mydata.selectEndFrame = mydata.selectDragStartFrame;
				mydata.playStartFrame = pointedFrame;
			}else{
				mydata.selectStartFrame = mydata.selectDragStartFrame;
				mydata.selectEndFrame = pointedFrame;
				mydata.playStartFrame = mydata.selectStartFrame;
			}

			if (mydata.selectEndFrame - mydata.selectStartFrame > 1){
				mydata.selected = true;
			}else{
				mydata.selected = false;
				mydata.playStartFrame = mydata.selectStartFrame;
			}

			mydata.dragging = false;
			redrawCanvas();
		}else{
			if(mydata.selected){
				if(mydata.shiftDraggingForLeft){
					mydata.selectStartFrame = pointedFrame;
					mydata.playStartFrame = pointedFrame;
				}else{
					mydata.selectEndFrame = pointedFrame;
				}
				
			}else{
				//not come here
				console.log("something wrong");
			}
			mydata.shiftDragging = false;
			redrawCanvas();
		}
		
	}

	function onCanvasScroll(e){
		e.preventDefault();
		// console.log(e);

		if (Math.abs(e.wheelDeltaY) > Math.abs(e.wheelDeltaX)){

			const deltaY = e.wheelDeltaY;
	    	const canvas = document.querySelector("#canvas2");
	      	const w = canvas.width
			const viewGravcenterRatio = /*e.offsetX*/(e.clientX-e.currentTarget.getBoundingClientRect().left) / w;
			let viewGravcenterFrame = Math.round(mydata.viewStartFrame
										+ viewGravcenterRatio * (mydata.viewEndFrame - mydata.viewStartFrame));

			mydata.viewRate += 0.005 * deltaY;
			if (mydata.viewRate < 1.0) mydata.viewRate = 1.0;

			if (mydata.viewRate == 1.0){
				mydata.viewStartFrame = 0;
				mydata.viewEndFrame = mydata.currentFrame;
			}else{
				const framePerPixel = (mydata.currentFrame)/w/mydata.viewRate;
				mydata.viewStartFrame = Math.round(viewGravcenterFrame - framePerPixel * viewGravcenterRatio * w);
				mydata.viewEndFrame = Math.round(viewGravcenterFrame + framePerPixel * (1 - viewGravcenterRatio) * w);
			}

			mydata.needsRedrawWave = true;
			redrawCanvas();
		}else{
			const deltaX = -e.wheelDeltaX;
			const prevStart = mydata.viewStartFrame;
			const prevEnd = mydata.viewEndFrame;
			mydata.viewStartFrame += Math.round(deltaX/mydata.viewRate*120);
			mydata.viewEndFrame += Math.round(deltaX/mydata.viewRate*120);

			if(mydata.viewStartFrame < 0){
				mydata.viewStartFrame = 0;
				mydata.viewEndFrame = mydata.viewStartFrame + (prevEnd - prevStart);
			}
			if(mydata.viewEndFrame > mydata.currentFrame){
				mydata.viewEndFrame = mydata.currentFrame;
				mydata.viewStartFrame = mydata.viewEndFrame - (prevEnd - prevStart);
			}
			mydata.needsRedrawWave = true;
			redrawCanvas();
		}

	}


</script>

<title>Dolphin Song</title>
</head>
<body>
<div id="control">
	<input id="chkMonitor" type="checkbox" value="true" onclick="onMonitorChanged();">monitor[m]</input>
	<input type="button" value="startRecord" onclick="startRecord();"/>
	<input type="button" value="stopRecord" onclick="stopRecord();"/>
	<input type="button" value="startPlay" onclick="startPlay();"/>
	<input type="button" value="stopPlay" onclick="stopPlay();"/>
</div>
<div id="editor">
	<canvas id="canvas" width="500" height="200"></canvas>
	<canvas id="canvas2" width="500" height="200"></canvas>
</div>
<div id="player">
	<table>
		<tr>
			<th>track1</th>
			<th>track2</th>
			<th>track3</th>
			<th>track4</th>
		</tr>
		<tr>
			<td class="loadButton" dropzone="copy">load</td>
			<td class="loadButton" dropzone="copy">load</td>
			<td class="loadButton" dropzone="copy">load</td>
			<td class="loadButton" dropzone="copy">load</td>
		</tr>	
		<tr>
			<td class="playButton">play</td>
			<td class="playButton">play</td>
			<td class="playButton">play</td>
			<td class="playButton">play</td>
		</tr>	
		<tr>
			<td class="playButton">
				<input type="range"/><output>num</output>
			</td>
			<td class="playButton">
				<input type="range"/><output>num</output>
			</td>
			<td class="playButton">
				<input type="range"/><output>num</output>
			</td>
			<td class="playButton">
				<input type="range"/><output>num</output>
			</td>
		</tr>	
	</table>

</body>
</html>
